var R=Object.defineProperty;var C=(e,r,n)=>r in e?R(e,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[r]=n;var S=(e,r,n)=>C(e,typeof r!="symbol"?r+"":r,n);import{y as h,b as g,z as A,A as L,E as U,F as B,G as V,u as F,I as J,J as z}from"./chrome-DWD2nxvx.js";function W(e){return e==null||typeof e=="function"?{main:e}:e}const G=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,globalThis.DOMException,globalThis.AssertionError,globalThis.SystemError].filter(Boolean).map(e=>[e.name,e]),H=new Map(G);class _ extends Error{constructor(n){super(_._prepareSuperMessage(n));S(this,"name","NonError")}static _prepareSuperMessage(n){try{return JSON.stringify(n)}catch{return String(n)}}}const q=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0},{property:"cause",enumerable:!1}],v=new WeakSet,Y=e=>{v.add(e);const r=e.toJSON();return v.delete(e),r},N=e=>H.get(e)??Error,O=({from:e,seen:r,to:n,forceEnumerable:s,maxDepth:o,depth:f,useToJSON:l,serialize:d})=>{if(!n)if(Array.isArray(e))n=[];else if(!d&&P(e)){const t=N(e.name);n=new t}else n={};if(r.push(e),f>=o)return n;if(l&&typeof e.toJSON=="function"&&!v.has(e))return Y(e);const a=t=>O({from:t,seen:[...r],forceEnumerable:s,maxDepth:o,depth:f,useToJSON:l,serialize:d});for(const[t,i]of Object.entries(e)){if(i&&i instanceof Uint8Array&&i.constructor.name==="Buffer"){n[t]="[object Buffer]";continue}if(i!==null&&typeof i=="object"&&typeof i.pipe=="function"){n[t]="[object Stream]";continue}if(typeof i!="function"){if(!i||typeof i!="object"){try{n[t]=i}catch{}continue}if(!r.includes(e[t])){f++,n[t]=a(e[t]);continue}n[t]="[Circular]"}}for(const{property:t,enumerable:i}of q)typeof e[t]<"u"&&e[t]!==null&&Object.defineProperty(n,t,{value:P(e[t])?a(e[t]):e[t],enumerable:s?!0:i,configurable:!0,writable:!0});return n};function K(e,r={}){const{maxDepth:n=Number.POSITIVE_INFINITY,useToJSON:s=!0}=r;return typeof e=="object"&&e!==null?O({from:e,seen:[],forceEnumerable:!0,maxDepth:n,depth:0,useToJSON:s,serialize:!0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}function Q(e,r={}){const{maxDepth:n=Number.POSITIVE_INFINITY}=r;if(e instanceof Error)return e;if(X(e)){const s=N(e.name);return O({from:e,seen:[],to:new s,maxDepth:n,depth:0,serialize:!1})}return new _(e)}function P(e){return!!e&&typeof e=="object"&&"name"in e&&"message"in e&&"stack"in e}function X(e){return!!e&&typeof e=="object"&&"message"in e&&!Array.isArray(e)}var Z=Object.defineProperty,ee=Object.defineProperties,re=Object.getOwnPropertyDescriptors,M=Object.getOwnPropertySymbols,ne=Object.prototype.hasOwnProperty,te=Object.prototype.propertyIsEnumerable,D=(e,r,n)=>r in e?Z(e,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[r]=n,k=(e,r)=>{for(var n in r||(r={}))ne.call(r,n)&&D(e,n,r[n]);if(M)for(var n of M(r))te.call(r,n)&&D(e,n,r[n]);return e},x=(e,r)=>ee(e,re(r)),oe=(e,r,n)=>new Promise((s,o)=>{var f=a=>{try{d(n.next(a))}catch(t){o(t)}},l=a=>{try{d(n.throw(a))}catch(t){o(t)}},d=a=>a.done?s(a.value):Promise.resolve(a.value).then(f,l);d((n=n.apply(e,r)).next())});function se(e){let r,n={};function s(){Object.entries(n).length===0&&(r==null||r(),r=void 0)}let o=Math.floor(Math.random()*1e4);function f(){return o++}return{sendMessage(l,d,...a){return oe(this,null,function*(){var t,i,u,y;const b={id:f(),type:l,data:d,timestamp:Date.now()},m=(i=yield(t=e.verifyMessageData)==null?void 0:t.call(e,b))!=null?i:b;(u=e.logger)==null||u.debug(`[messaging] sendMessage {id=${m.id}} ─ᐅ`,m,...a);const w=yield e.sendMessage(m,...a),{res:c,err:p}=w??{err:new Error("No response")};if((y=e.logger)==null||y.debug(`[messaging] sendMessage {id=${m.id}} ᐊ─`,{res:c,err:p}),p!=null)throw Q(p);return c})},onMessage(l,d){var a,t,i;if(r==null&&((a=e.logger)==null||a.debug(`[messaging] "${l}" initialized the message listener for this context`),r=e.addRootListener(u=>{var y,b;if(typeof u.type!="string"||typeof u.timestamp!="number"){if(e.breakError)return;const c=Error(`[messaging] Unknown message format, must include the 'type' & 'timestamp' fields, received: ${JSON.stringify(u)}`);throw(y=e.logger)==null||y.error(c),c}(b=e==null?void 0:e.logger)==null||b.debug("[messaging] Received message",u);const m=n[u.type];if(m==null)return;const w=m(u);return Promise.resolve(w).then(c=>{var p,j;return(j=(p=e.verifyMessageData)==null?void 0:p.call(e,c))!=null?j:c}).then(c=>{var p;return(p=e==null?void 0:e.logger)==null||p.debug(`[messaging] onMessage {id=${u.id}} ─ᐅ`,{res:c}),{res:c}}).catch(c=>{var p;return(p=e==null?void 0:e.logger)==null||p.debug(`[messaging] onMessage {id=${u.id}} ─ᐅ`,{err:c}),{err:K(c)}})})),n[l]!=null){const u=Error(`[messaging] In this JS context, only one listener can be setup for ${l}`);throw(t=e.logger)==null||t.error(u),u}return n[l]=d,(i=e.logger)==null||i.log(`[messaging] Added listener for ${l}`),()=>{delete n[l],s()}},removeAllListeners(){Object.keys(n).forEach(l=>{delete n[l]}),s()}}}function ie(e){return se(x(k({},e),{sendMessage(r,n){return n==null?h.runtime.sendMessage(r):h.tabs.sendMessage(n,r)},addRootListener(r){const n=(s,o)=>r(typeof s=="object"?x(k({},s),{sender:o}):s);return h.runtime.onMessage.addListener(n),()=>h.runtime.onMessage.removeListener(n)}}))}const{sendMessage:$,onMessage:E}=ie(),T=14;async function I(e){if(console.log("picking from webpage"),e??(e=await ue()),e==null)return{status:"noTab"};await ce(e);const r={cursor:"default",enableColorToolbox:!0,enableColorTooltip:!0,enableRightClickDeactivate:!0},n=3e3,s=new Promise(o=>setTimeout(()=>o({status:"timeout"}),n));try{return await Promise.race([$("pickupActivate",r,e),s])}catch(o){return o instanceof Error?o.message=="Could not establish connection. Receiving end does not exist."?{status:"injectFailed",error:o.message}:(console.error(o),{status:"unknownError",error:o.message}):(console.error(o),{status:"unknownError",error:`${o}`})}}async function ae(e){console.log("needInject?");try{const r=await $("getVersion",void 0,e);return console.log("checking",r),r<T?(console.log(`eDropper is ${r} which is lower than ${T}`),!0):(console.log(`eDropper version is already ${r}`),!1)}catch{return console.log("not injected"),!0}}async function le(){return(await g.tabs.query({active:!0,currentWindow:!0}))[0]}async function ue(){return(await le()).id}async function ce(e){console.log("want to inject"),await ae(e)&&(console.log("need inject, injecting..."),await g.scripting.executeScript({target:{tabId:e},files:["edropper.js"]}))}async function pe(){return g.tabs.captureVisibleTab().then(r=>r,r=>(console.log("error when trying to capture screenshot",r),null))}async function de(e){console.log(`Setting color to ${e}`),F(e,"ed")}async function fe(){E("pickFromWeb",e=>I(e.data)),E("setColor",e=>{de(e.data)}),E("capture",()=>pe())}function ge(e){switch(console.log(`commandHandler: ${e}`),e){case"pick-from-webpage":I();break}}async function me(e){console.log("Extension installed:",e);const r="https://www.extensions-hub.com/partners/installed/?name=Eye+Dropper&propRef=Eye-Dropper";if(g.runtime.setUninstallURL("https://www.extensions-hub.com/partners/uninstalled/?name=Eye+Dropper&propRef=Eye-Dropper"),await A(),e.reason==="install")console.info("Extension has been installed."),g.tabs.create({url:r,active:!0});else if(e.reason==="update"){console.info("Extension has been updated");const s=await L(),o=U("4.10.3.11"),f=await B("enablePromoOnUpdate");await V(),s&&o!==null&&f&&(console.info("This is big update, show update tab."),g.tabs.create({url:`https://eyedropper.org/chrome/updated/${o}/`,active:!0}))}}async function ye(){console.log("init badge"),await g.action.setBadgeText({text:" "});const e=await J();e&&z(e)}async function be(){console.log("worker init"),ye()}const Ee=W({type:"module",main(){g.commands.onCommand.addListener(ge),g.runtime.onInstalled.addListener(me),fe(),be()}});export{Ee as d,le as g,$ as s};
